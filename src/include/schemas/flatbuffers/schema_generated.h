// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_MYGAME_H_
#define FLATBUFFERS_GENERATED_SCHEMA_MYGAME_H_

#include "flatbuffers/flatbuffers.h"

namespace MyGame {

struct Head;

struct Dot;

struct Table;

struct Document;

enum Compression {
  Compression_zstd = 1,
  Compression_lz4 = 2,
  Compression_MIN = Compression_zstd,
  Compression_MAX = Compression_lz4
};

inline const Compression (&EnumValuesCompression())[2] {
  static const Compression values[] = {
    Compression_zstd,
    Compression_lz4
  };
  return values;
}

inline const char * const *EnumNamesCompression() {
  static const char * const names[] = {
    "zstd",
    "lz4",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompression(Compression e) {
  if (e < Compression_zstd || e > Compression_lz4) return "";
  const size_t index = static_cast<int>(e) - static_cast<int>(Compression_zstd);
  return EnumNamesCompression()[index];
}

enum Any {
  Any_NONE = 0,
  Any_Dot = 1,
  Any_Table = 2,
  Any_MIN = Any_NONE,
  Any_MAX = Any_Table
};

inline const Any (&EnumValuesAny())[3] {
  static const Any values[] = {
    Any_NONE,
    Any_Dot,
    Any_Table
  };
  return values;
}

inline const char * const *EnumNamesAny() {
  static const char * const names[] = {
    "NONE",
    "Dot",
    "Table",
    nullptr
  };
  return names;
}

inline const char *EnumNameAny(Any e) {
  if (e < Any_NONE || e > Any_Table) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesAny()[index];
}

template<typename T> struct AnyTraits {
  static const Any enum_value = Any_NONE;
};

template<> struct AnyTraits<Dot> {
  static const Any enum_value = Any_Dot;
};

template<> struct AnyTraits<Table> {
  static const Any enum_value = Any_Table;
};

bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type);
bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Head FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TS = 4,
    VT_FILE = 6,
    VT_LINE = 8
  };
  int64_t ts() const {
    return GetField<int64_t>(VT_TS, 0);
  }
  bool mutate_ts(int64_t _ts) {
    return SetField<int64_t>(VT_TS, _ts, 0);
  }
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  flatbuffers::String *mutable_file() {
    return GetPointer<flatbuffers::String *>(VT_FILE);
  }
  int64_t line() const {
    return GetField<int64_t>(VT_LINE, 0);
  }
  bool mutate_line(int64_t _line) {
    return SetField<int64_t>(VT_LINE, _line, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TS) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           VerifyField<int64_t>(verifier, VT_LINE) &&
           verifier.EndTable();
  }
};

struct HeadBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ts(int64_t ts) {
    fbb_.AddElement<int64_t>(Head::VT_TS, ts, 0);
  }
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(Head::VT_FILE, file);
  }
  void add_line(int64_t line) {
    fbb_.AddElement<int64_t>(Head::VT_LINE, line, 0);
  }
  explicit HeadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeadBuilder &operator=(const HeadBuilder &);
  flatbuffers::Offset<Head> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Head>(end);
    return o;
  }
};

inline flatbuffers::Offset<Head> CreateHead(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ts = 0,
    flatbuffers::Offset<flatbuffers::String> file = 0,
    int64_t line = 0) {
  HeadBuilder builder_(_fbb);
  builder_.add_line(line);
  builder_.add_ts(ts);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Head> CreateHeadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ts = 0,
    const char *file = nullptr,
    int64_t line = 0) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  return MyGame::CreateHead(
      _fbb,
      ts,
      file__,
      line);
}

struct Dot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_H = 4,
    VT_SRC = 6
  };
  const Head *h() const {
    return GetPointer<const Head *>(VT_H);
  }
  Head *mutable_h() {
    return GetPointer<Head *>(VT_H);
  }
  const flatbuffers::String *src() const {
    return GetPointer<const flatbuffers::String *>(VT_SRC);
  }
  flatbuffers::String *mutable_src() {
    return GetPointer<flatbuffers::String *>(VT_SRC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_H) &&
           verifier.VerifyTable(h()) &&
           VerifyOffset(verifier, VT_SRC) &&
           verifier.VerifyString(src()) &&
           verifier.EndTable();
  }
};

struct DotBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_h(flatbuffers::Offset<Head> h) {
    fbb_.AddOffset(Dot::VT_H, h);
  }
  void add_src(flatbuffers::Offset<flatbuffers::String> src) {
    fbb_.AddOffset(Dot::VT_SRC, src);
  }
  explicit DotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DotBuilder &operator=(const DotBuilder &);
  flatbuffers::Offset<Dot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dot>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dot> CreateDot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Head> h = 0,
    flatbuffers::Offset<flatbuffers::String> src = 0) {
  DotBuilder builder_(_fbb);
  builder_.add_src(src);
  builder_.add_h(h);
  return builder_.Finish();
}

inline flatbuffers::Offset<Dot> CreateDotDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Head> h = 0,
    const char *src = nullptr) {
  auto src__ = src ? _fbb.CreateString(src) : 0;
  return MyGame::CreateDot(
      _fbb,
      h,
      src__);
}

struct Table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_H = 4,
    VT_DATA = 6
  };
  const Head *h() const {
    return GetPointer<const Head *>(VT_H);
  }
  Head *mutable_h() {
    return GetPointer<Head *>(VT_H);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_H) &&
           verifier.VerifyTable(h()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct TableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_h(flatbuffers::Offset<Head> h) {
    fbb_.AddOffset(Table::VT_H, h);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Table::VT_DATA, data);
  }
  explicit TableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableBuilder &operator=(const TableBuilder &);
  flatbuffers::Offset<Table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Table>(end);
    return o;
  }
};

inline flatbuffers::Offset<Table> CreateTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Head> h = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  TableBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_h(h);
  return builder_.Finish();
}

inline flatbuffers::Offset<Table> CreateTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Head> h = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return MyGame::CreateTable(
      _fbb,
      h,
      data__);
}

struct Document FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS_TYPE = 4,
    VT_ITEMS = 6
  };
  const flatbuffers::Vector<uint8_t> *items_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS_TYPE);
  }
  flatbuffers::Vector<uint8_t> *mutable_items_type() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ITEMS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ITEMS);
  }
  flatbuffers::Vector<flatbuffers::Offset<void>> *mutable_items() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS_TYPE) &&
           verifier.VerifyVector(items_type()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           VerifyAnyVector(verifier, items(), items_type()) &&
           verifier.EndTable();
  }
};

struct DocumentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items_type) {
    fbb_.AddOffset(Document::VT_ITEMS_TYPE, items_type);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> items) {
    fbb_.AddOffset(Document::VT_ITEMS, items);
  }
  explicit DocumentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DocumentBuilder &operator=(const DocumentBuilder &);
  flatbuffers::Offset<Document> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Document>(end);
    return o;
  }
};

inline flatbuffers::Offset<Document> CreateDocument(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> items = 0) {
  DocumentBuilder builder_(_fbb);
  builder_.add_items(items);
  builder_.add_items_type(items_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Document> CreateDocumentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *items = nullptr) {
  auto items_type__ = items_type ? _fbb.CreateVector<uint8_t>(*items_type) : 0;
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<void>>(*items) : 0;
  return MyGame::CreateDocument(
      _fbb,
      items_type__,
      items__);
}

inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type) {
  switch (type) {
    case Any_NONE: {
      return true;
    }
    case Any_Dot: {
      auto ptr = reinterpret_cast<const Dot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_Table: {
      auto ptr = reinterpret_cast<const Table *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAny(
        verifier,  values->Get(i), types->GetEnum<Any>(i))) {
      return false;
    }
  }
  return true;
}

inline const MyGame::Document *GetDocument(const void *buf) {
  return flatbuffers::GetRoot<MyGame::Document>(buf);
}

inline const MyGame::Document *GetSizePrefixedDocument(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MyGame::Document>(buf);
}

inline Document *GetMutableDocument(void *buf) {
  return flatbuffers::GetMutableRoot<Document>(buf);
}

inline bool VerifyDocumentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MyGame::Document>(nullptr);
}

inline bool VerifySizePrefixedDocumentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MyGame::Document>(nullptr);
}

inline void FinishDocumentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MyGame::Document> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDocumentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MyGame::Document> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MyGame

#endif  // FLATBUFFERS_GENERATED_SCHEMA_MYGAME_H_
